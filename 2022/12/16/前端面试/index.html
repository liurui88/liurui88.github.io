<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>前端面试 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Js js 继承 原型链继承 123SubType.prototype &#x3D; new SuperType()&#x2F;&#x2F; 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。SubType.prototype.constructor &#x3D; SubType;  构造函数继承 1SuperType.call(SubType);  ES6 Class exten">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试">
<meta property="og:url" content="http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Js js 继承 原型链继承 123SubType.prototype &#x3D; new SuperType()&#x2F;&#x2F; 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。SubType.prototype.constructor &#x3D; SubType;  构造函数继承 1SuperType.call(SubType);  ES6 Class exten">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-16T06:33:27.000Z">
<meta property="article:modified_time" content="2022-12-16T06:35:19.755Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-16 14:35:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-16T06:33:27.000Z" title="发表于 2022-12-16 14:33:27">2022-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-16T06:35:19.755Z" title="更新于 2022-12-16 14:35:19">2022-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h2><ol>
<li><p>js 继承</p>
<p>原型链继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>()</span><br><span class="line"><span class="comment">// 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>;</span><br></pre></td></tr></table></figure>

<p>构造函数继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="title class_">SubType</span>);</span><br></pre></td></tr></table></figure>

<p>ES6 Class extends</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">super</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Promise</p>
<ul>
<li><p>三种状态：pending（进行中）、resolved（已完成）、rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都不能改变这个状态。</p>
</li>
<li><p>两种状态的转化：其一，从pending（进行中）到resolved（已完成）。其二，从pending（进行中）到rejected（已失败）。只有这两种形式的转变。</p>
</li>
<li><p>也有一些缺点，一旦执行了promise便无法中途取消，</p>
</li>
</ul>
<p>注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个table数据</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">requestTableList</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="comment">//去后台请求数据，这里可以是ajax,可以是axios,可以是fetch </span></span><br><span class="line">               <span class="title function_">resolve</span>(res);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">//延时函数，用于给请求计时 10s</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">             <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                 <span class="title function_">reject</span>(<span class="string">&#x27;请求超时&#x27;</span>);</span><br><span class="line">             &#125;, <span class="number">10000</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">requestTableList</span>(), <span class="title function_">timeout</span>()]).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span>&#123;</span><br><span class="line">       <span class="comment">//进行成功回调处理</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">     &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 失败回调处理</span></span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<p>Promise.all</p>
<p>只要p1、p2、p3有一个失败了就返回失败，只有全部成功了才能进入到.then()中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2]).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result)               <span class="comment">//[&#x27;成功了&#x27;, &#x27;success&#x27;]</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p3,p2]).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error)      <span class="comment">// 失败了，打出 &#x27;失败&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>async/await</p>
<p>async/await是基于Promise实现的，它不能用于普通的回调函数</p>
<p>async/await与Promise一样，是非阻塞的</p>
</li>
<li><p>事件循环</p>
</li>
<li><p>闭包</p>
<p>定义：闭包是指有权访问一个函数作用域中局部变量的函数。</p>
<p>作用：</p>
<p>1.延长了局部变量的作用域范围。</p>
<p>2.使函数外部可读取到函数内部的数据。</p>
<p>缺点：</p>
<p>1.函数执行完后，函数内的局部变量没有释放，占用内存时间会变长<br>2.容易造成内存泄漏</p>
</li>
<li><p>this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数的调用，this指向的是Window</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cat</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;有鱼&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);<span class="comment">//卡卡</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//Window &#123;frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">cat</span>();</span><br><span class="line"><span class="comment">//对象的方法，this指的是该对象</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;有鱼&#x27;</span>,</span><br><span class="line">  <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);<span class="comment">//有鱼</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">cat.<span class="title function_">eat</span>();</span><br><span class="line"><span class="comment">//构造函数的调用，this指的是实例化的新对象</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;有鱼&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;英短蓝猫&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1);<span class="comment">// 实例化新对象 Cat &#123;name: &quot;有鱼&quot;, type: &quot;英短蓝猫&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">name</span>);<span class="comment">// 有鱼</span></span><br><span class="line"><span class="comment">//定时器中调用，指向的是全局变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;有鱼&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);<span class="comment">// 卡卡</span></span><br><span class="line">  <span class="built_in">clearInterval</span>(cat);</span><br><span class="line">&#125;,<span class="number">500</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数与普通函数</p>
<p>普通函数存在变量提升的现象</p>
<p>箭头函数不能作为构造函数使用</p>
<p>普通函数的this指向的是谁调用该函数就指向谁</p>
<p>箭头函数的this指向的是在你书写代码时候的上下文环境对象的this，如果没有上下文环境对象，那么就指向最外层对象window。</p>
</li>
<li><p>去重</p>
</li>
<li><p>防抖节流</p>
<p>1）区别</p>
<p>防抖：多次触发 只执行最后一次</p>
<p>节流：规定时间内 只触发一次</p>
<p>2）应用场景</p>
<p>防抖：登录、短信验证等按钮避免用户点击太快，发行多次请求；调整浏览器窗口大小时，resize 次数过于频繁，计算过多，造成页面卡顿的情况；文本编辑器实时保存；搜索框等。</p>
<p>节流： 鼠标连续不断地触发某事件（如点击事件），单位时间内只触发一次；监听滚动事件，例如：懒加载；每隔多少秒计算一次相关数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">防抖</span><br><span class="line"><span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖原理：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; func 要执行的回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; wait 延时的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; immediate 是否立即执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">null</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait = <span class="number">500</span>, immediate = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 清除定时器</span></span><br><span class="line">    <span class="keyword">if</span> (timeout !== <span class="literal">null</span>) <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    <span class="comment">// 立即执行，此类情况一般用不到</span></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        <span class="keyword">const</span> callNow = !timeout</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;, wait)</span><br><span class="line">        <span class="keyword">if</span> (callNow) <span class="keyword">typeof</span> func === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">func</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法</span></span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">typeof</span> func === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">func</span>()</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> debounce</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">节流</span><br><span class="line"><span class="keyword">let</span> timer; <span class="keyword">let</span></span><br><span class="line">    flag</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流原理：在一定时间内，只能触发一次</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; func 要执行的回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; wait 延时的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; immediate 是否立即执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">null</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait = <span class="number">500</span>, immediate = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 如果是立即执行，则在wait毫秒内开始时执行</span></span><br><span class="line">            <span class="keyword">typeof</span> func === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">func</span>()</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 如果是非立即执行，则在wait毫秒内的结束处执行</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">typeof</span> func === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">func</span>()</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> throttle</span><br></pre></td></tr></table></figure></li>
<li><p>原型链</p>
<p>原型：每一个javascript对象(除null外)创建的时候，都会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>
<p>在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。</p>
<p>这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。</p>
<p>__proto__和prototype</p>
<p>__proto__是实例指向原型的属性</p>
<p>prototype是对象或者构造函数指向原型的属性</p>
<p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>
</li>
<li><p>Object.definePrototype、Proxy</p>
</li>
<li><p>let const var 区别</p>
<p>2）变量提升： var存在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87&spm=1001.2101.3001.7020">变量提升</a>，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
<p>3）给全局添加属性： 浏览器的全局对象是window，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Node&spm=1001.2101.3001.7020">Node</a>的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p>
<p>4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p>
<p>5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。</p>
<p>6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p>
</li>
<li><p>e .getAttribute(propName)和 e.propName 区别</p>
</li>
<li><p>scrollWidth、offsetWidth、clientWidth 区别</p>
<p>clientWidth = width+左右padding</p>
<p>clientHeight = height +上下padding</p>
<p>offsetWidth = width +左右padding +左右border</p>
<p>offsetHeitht = height +上下padding+上下border</p>
<p>scrollWidth:获取指定标签内容层的真实宽度(可视区域宽度+被隐藏区域宽度)。</p>
<p>scrollHeight:获取指定标签内容层的真实高度(可视区域高度+被隐藏区域高度)</p>
</li>
<li><p>垃圾回收机制</p>
</li>
<li><p>js 数据类型</p>
<p>js常用的基本数据类型包括undefined - - (未定义)、null- - (空的)、number - - (数字)、boolean- - (布尔值)、string- - (字符串)、Symbol - - (符号)；</p>
<p>js的引用数据类型也就是对象类型Object- - (对象)，比如：array - - （数组）、function - - （函数）、date - - （时间）等；</p>
</li>
<li><p>js 判断数据类型</p>
<p>typeof</p>
<p>constructor</p>
<p>instanceof</p>
</li>
<li><p>typeof与instanceof的区别</p>
<p>typeof返回字符串，也就是返回一个变量基本类型，instanceof返回布尔值</p>
<p>typeof存在弊端，无法检测null类型和除了function以外的引用类型。</p>
</li>
<li><p>JS 对象深拷贝 JSON.Stringify() + JSON.parse()，缺点不能拷贝 function</p>
</li>
<li><p>事件流、事件委托与冒泡</p>
<p>首先发生的是事件捕获，此时事件还没有传递到目标节点对象上，所以我们就有机会在这个阶段进行事件的截获。再就是目标节点接收到事件，最后是事件冒泡阶段，可以在这个阶段对事件做出处理和响应。</p>
<p>event.stopPropagation()方法阻止事件冒泡过程，以防止事件冒泡而带来不必要的错误</p>
</li>
<li><p>dom 添加事件的方式、区别</p>
</li>
<li><p>动态加载 Script 方式</p>
<p>document.write</p>
</li>
<li><p>undefined 和 null 有什么区别？</p>
<p>1）相同点</p>
<p><code>Undefined</code>和<code>Null</code>类型在转换为<code>Boolean</code>类型的值时，都会转换为<code>false</code>.</p>
<p>在需要将两者转换成对象的时候，都会抛出一个<code>TypeError</code>的异常。</p>
<p><code>Undefined</code>类型派生自<code>Null</code>类型，所以在非严格相等的比较下，两者是相等的。如下面代码所示：null==undefined //true</p>
<p>2）不同点</p>
<p>在使用<code>typeof</code>运算符进行检测时，<code>Undefined</code>类型的值会返回<code>undefined</code>.而<code>Null</code>类型的值返回为<code>object</code></p>
<p>在进行数值类型的转换时，<code>undefined</code>会转换为<code>NaN</code>,无法参与计算，而<code>null</code>会转换为<code>0</code>,可以参与计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> +<span class="number">0</span>;<span class="comment">// NaN </span></span><br><span class="line"><span class="literal">null</span>+<span class="number">0</span> ;<span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
<li><p>bind、apply、call 的区别？手写实现 apply。</p>
<p>1)call</p>
<p><strong>语法</strong>：函数名.call(调用者, 参数1, …)</p>
<p><strong>作用</strong>：函数被借用时，会立即执行，并且函数体内的this会指向借用者或调用者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// 经过apply，this指向obj，obj开始有name、age属性</span></span><br><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="string">&#x27;李四&#x27;</span>, <span class="number">100</span>])</span><br><span class="line"><span class="comment">// 以下this均指向window,name:undefined,age:undefined</span></span><br><span class="line">fn.<span class="title function_">apply</span>()</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">null</span>)</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>2)apply</p>
<p><strong>语法</strong>：函数名.apply(调用者, [参数, …])</p>
<p><strong>作用</strong>：函数被借用时，会立即执行，并且函数体内的this会指向借用者或调用者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// 经过apply，this指向obj，obj开始有name、age属性</span></span><br><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="string">&#x27;李四&#x27;</span>, <span class="number">100</span>])</span><br><span class="line"><span class="comment">// 以下this均指向window,name:undefined,age:undefined</span></span><br><span class="line">fn.<span class="title function_">apply</span>()</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">null</span>)</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>3)bind</p>
<p><strong>语法</strong>：函数名.bind(调用者, 参数, …)</p>
<p><strong>作用</strong>：函数被借用时，不会立即执行，而是返回一个新的函数。需要自己手动调用新的函数来改变this指向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// const newFn = fn.bind(obj, &#x27;李四&#x27;, 100)</span></span><br><span class="line"><span class="comment">// newFn()</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj, <span class="string">&#x27;李四&#x27;</span>, <span class="number">100</span>)()</span><br></pre></td></tr></table></figure>

<p>call，apply是直接执行函数调用。bind是绑定，执行需要再次调用。</p>
<p>call，bind接收逗号分隔的无限个参数列表；apply接收数组作为参数。</p>
</li>
<li><p>JS 文件执行顺序和页面渲染有什么关系吗</p>
<blockquote>
<p>通常 JS 代码会改变 DOM 树的结构，所以浏览器在解析 HTML 时如果遇到 JS 则会停下来先去执行 JS 文件再继续解析 HTML，这就可能会导致加载白屏。</p>
</blockquote>
</li>
<li><p>描述下作用域？作用域链呢？</p>
<p>全局作用域、函数作用域、块级作用域。</p>
<p>当执行一个项目或一个文件时，会先生成全局作用域；<br> 在执行每一个函数时，会生成对应的函数作用域；<br> 这两个作用域都是 JS 设计之初就有的，而块级作用域则是 ES6 才实现的。这篇文章主要讲 ES6 实现的块级作用域</p>
<p>全局作用域：在函数之外，使用var进行定义，在全局中都能使用的变量，称为全局变量。全局变量对应的作用域就是全局作用域。</p>
<p>函数作用域：在函数之内，使用var进行定义，只能在该函数中使用的变量，称为函数变量（也称局部变量）。局部变量对应的作用域就是函数作用域（也称局部作用域）。</p>
<p>块级作用域：es6中，可以通过关键词let来定义变量。通过let定义的变量，只能在当前代码块（以 { } 为界限）中使用，对应的作用域为块级作用域。</p>
<p>作用域链：当你要访问一个变量时，首先会在当前作用域下查找，如果当前作用域下没有查找到，则返回上一级作用域进行查找，直到找到全局作用域，这个查找过程形成的链条叫做作用域链。</p>
</li>
<li><p>执行上下文？与闭包的关系？</p>
</li>
<li><p>双等和三等？null，undefined 双等和三等的区别？</p>
<p>当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行三等比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而三等比较时， 如果类型不同，直接就是false.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>==<span class="literal">undefined</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span>===<span class="literal">undefined</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
<li><p>js 如何实现多线程？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(js文件路径);</span><br><span class="line"><span class="comment">//postMessage(msg);</span></span><br><span class="line"><span class="comment">//postMessage方法把在新线程执行的结果发送到浏览器的js引擎线程里</span></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//获取在新线程中执行的js文件发送的数据 用event.data接收数据</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>( event.<span class="property">data</span> )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>( <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    worker.<span class="title function_">terminate</span>();</span><br><span class="line">    <span class="comment">//terminate方法用于关闭worker线程</span></span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">     </span><br><span class="line"><span class="built_in">setTimeout</span>( <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;js/test22.js&quot;</span>);</span><br><span class="line">    <span class="comment">//再次开启worker线程</span></span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>webWorker</p>
</li>
<li><p>深浅拷贝</p>
<p>遍历 </p>
<p>如果数据没有函数和undefined 使用json.string() json.parse() 或json.parse(json.string(obj))</p>
</li>
<li><p>weakmap 和 weakset 的区别</p>
</li>
<li><p>防抖节流(及应用场景)</p>
<p>防抖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是事件触发执行的函数</span></span><br><span class="line"><span class="comment">// wait是指等待时长，在wait时间内多次触发函数只会被执行一次</span></span><br><span class="line"><span class="comment">// immediate是否立即执行，true表示wait秒内触发只会执行第一次触发；false表示wait秒内触发只会执行最后一次触发</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait = <span class="number">1000</span>, immediate = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span>(immediate) &#123;</span><br><span class="line">      <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">      <span class="comment">// wait秒后清除定时器</span></span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;timeout = <span class="literal">null</span>;&#125;, wait);</span><br><span class="line">      <span class="comment">// 先执行函数</span></span><br><span class="line">      <span class="keyword">if</span>(callNow) fn.<span class="title function_">apply</span>(ctx, args)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// wait秒后执行fn</span></span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;fn.<span class="title function_">apply</span>(ctx, args)&#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节流</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是事件触发执行的函数</span></span><br><span class="line"><span class="comment">// wait是指间隔时长，在wait时间内多次触发函数只会被执行一次</span></span><br><span class="line"><span class="comment">// timeStamp: true时间戳版，false定时器版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait = <span class="number">1000</span>, timeStamp = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span>(timeStamp)&#123;</span><br><span class="line">      <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">if</span>(now - previous &gt; wait) &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">        previous = now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!timeout) &#123;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">          fn.<span class="title function_">apply</span>(ctx, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>事件代理</p>
</li>
</ol>
<h2 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h2><ol>
<li><p>z-index 细节</p>
</li>
<li><p>flex</p>
</li>
<li><p>BFC 是什么</p>
</li>
<li><p>css 垂直居中</p>
</li>
<li><p>CSS 中的 absolute、relative、fixed。如果父 div 是 fixed/relative，子 div 是 absolute，如何确定位置</p>
<p>absolute 绝对定位</p>
<p>relative 相对定位</p>
<p>fixed 固定定位</p>
<p>都是根据父元素来确定位置</p>
</li>
<li><p>position 属性有哪些</p>
</li>
<li><p>link 和@import 引入 css 的区别</p>
</li>
<li><p>css 的选择器</p>
<p>元素选择器 p{} li{}</p>
<p>类选择器(class选择器)  .class属性值{}</p>
<p>id选择器            #id属性值{}</p>
<p>通配符选择器    *{}</p>
<p>后代选择器        .box p{}</p>
<p>子代选择器        .box&gt;p{}</p>
<p>相邻兄弟选择器 .box+p{}</p>
<p>伪类选择器 :first-child  第一个子元素 :nth-child()  选中第n个元素</p>
</li>
<li><p>伪类伪元素</p>
<p>伪类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;p&gt;a&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;b&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">p:first-child&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>伪元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;p class=&quot;first-child&quot;&gt;a&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;b&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">p:first-child&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>伪类只能使用“：”<br>而伪元素既可以使用“:”，也可以使用“::”</p>
</li>
<li><p>行内元素和块级元素，两个的区别</p>
<p>行内元素会在一条直线上排列，都是同一行的，水平方向排列</p>
<p>块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。</p>
<p>块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。</p>
<p>行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</p>
</li>
<li><p>css 中可以继承的属性有哪些？</p>
</li>
<li><p>如何实现响应式布局</p>
<p>百分比布局</p>
<p>媒体查询</p>
<p>rem <strong>针对于html 元素的font-size 的值进行动态计算</strong></p>
<p>flex 弹性盒子布局</p>
</li>
<li><p>盒模型</p>
<p>标准盒子</p>
<p>width=content的宽度</p>
<p>怪异盒子</p>
<p>元素宽度width=content+padding+border</p>
</li>
<li><p>使用 css 实现一个三角形</p>
</li>
<li><p>Css 实现单行截断字符串</p>
</li>
<li><p>网站轮播图怎么实现、你说说 animation 怎么实现？</p>
</li>
<li><p>postMessage</p>
</li>
</ol>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ol>
<li><p>vue $nexttick 作用和原理</p>
<p>当某操作需要等 数据被修改更新之后 再操作，则可以将操作放在<code>this.$nextTick</code>的回调函数中执行。因为并不是vue数据一旦修改就会立即更新。</p>
</li>
<li><p>MVVM</p>
<p>我的理解MVVM它就是一种前端开发的架构模式，作用就是为了让前端业务逻辑和HTML代码更加分离。它的核心思想就是把每个页面分成了M（Model数据模型）、V（View视图）、VM（ViewModel视图模型）。其中VM是核心，时M和V之间的调度者。M和V不直接关联，通过中间的VM。VM还提供了数据双向绑定功能，也就说V发生改变M也跟这边，M发生改变V也会跟这变。这就是我对MVVM的简单理解。</p>
</li>
<li><p>Vue 的双向数据绑定原理</p>
<p><strong>vue中内部采用了发布-订阅模式</strong>。内部结合了<strong>Object.defineProperty</strong>这个ES5的新特性（ie8浏览器可不支持哦…），对vue传入的数据进行了相应的<strong>数据拦截</strong>，为其动态添加get与set方法。当数据变化的时候，就会触发对应的set方法，当set方法触发完成的时候，内部会进一步触发watcher,当数据改变了，接着进行虚拟dom对比，执行render,后续视图更新操作完毕。</p>
<p><strong>Proxy</strong>[ˈprɒksi]</p>
</li>
<li><p>diff 算法</p>
<p>渲染真实DOM的开销很大，有时候我们修改了某个数据，直接渲染到真实dom上会引起整个dom树的重绘和重排。我们希望只更新我们修改的那一小块dom，而不是整个dom，diff算法就帮我们实现了这点。<br>diff算法的本质就是：找出两个对象之间的差异，目的是尽可能做到节点复用。<br>此处说到的对象，指的其实就是vue中的virtual dom（虚拟dom树），即使用js对象来表示页面中的dom结构。</p>
</li>
<li><p>使用 v-for 渲染列表是 key 值的作用？</p>
<p>key是虚拟DOM对象的一个标识，当数据变化时，Vue会根据新数据生成新的虚拟DOM, 之后Vue进行新虚拟DOM与旧虚拟DOM的差异比较，比较规则如下：<br>旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p>
</li>
<li><p>vue computed 和 watch 原理</p>
<p>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</p>
<p>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</p>
<p>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</p>
<p>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</p>
<p>使用场景：computed—-当一个属性受多个属性影响的时候，使用computed—–购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch—–搜索框</p>
</li>
<li><p>观察者模式（手写）</p>
<p>观察者模式即一个对象被多个对象所依赖，当被依赖的对象发生更新时，会自动通知所有依赖的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>&#123;<span class="comment">// 目标</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>=[]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">observer</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params">newMsg</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span>=&gt;</span>i.<span class="title function_">consoleFn</span>(newMsg))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>&#123;<span class="comment">// 观察者</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">consoleFn</span>(<span class="params">newMsg</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newMsg + <span class="string">&#x27;======》》》&#x27;</span>+ <span class="variable language_">this</span>.<span class="property">name</span> +<span class="string">&#x27;收到了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub = <span class="keyword">new</span> <span class="title class_">Subject</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;观察者1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> observer2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;观察者2&quot;</span>)</span><br><span class="line"></span><br><span class="line">sub.<span class="title function_">add</span>(observer1) <span class="comment">// Observer1 观察 sub</span></span><br><span class="line">sub.<span class="title function_">add</span>(observer2) <span class="comment">// Observer2　观察　sub</span></span><br><span class="line"></span><br><span class="line">sub.<span class="title function_">notify</span>(<span class="string">&quot;我是被观察者，我发布了一个信息！&quot;</span>) <span class="comment">// sub 发布消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是被观察者，我发布了一个信息！======》》》观察者1收到了</span></span><br><span class="line"><span class="comment">// 我是被观察者，我发布了一个信息！======》》》观察者2收到了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>EventBus、Vuex 区别</p>
</li>
<li><p>父子组件传值</p>
<p>1）父传子</p>
<p>父组件使用v-bind绑定一个变量</p>
<p>子组件用props接收</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父组件使用v-bind绑定一个变量</span><br><span class="line">&lt;<span class="title class_">Invitation</span> v-<span class="attr">bind</span>:visible=<span class="string">&quot;dialogVisible&quot;</span> @getData=<span class="string">&quot;getdata&quot;</span> /&gt;</span><br><span class="line">子组件用props接收</span><br><span class="line"><span class="attr">props</span>: [<span class="string">&quot;visible&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>2）子传夫</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子组件使用<span class="variable language_">this</span>.<span class="property">$emit</span>绑定一个事件和值</span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&quot;getData&quot;</span>, <span class="variable language_">this</span>.<span class="property">data1</span>);</span><br><span class="line">父组件使用@子组件绑定事件=新方法名</span><br><span class="line">&lt;<span class="title class_">Invitation</span> v-<span class="attr">bind</span>:visible=<span class="string">&quot;dialogVisible&quot;</span> @getData=<span class="string">&quot;getdata&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>3）VueX传值</p>
</li>
<li><p>Keep-Alive 实现原理</p>
<p>keep-alive用于保存组件的渲染状态</p>
</li>
<li><p>data 为啥是函数</p>
<p>如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data(类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据)<br>Object是引用数据类型，里面保存的是内存地址，单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p>
</li>
<li><p>vue2.0/3.0 区别</p>
</li>
<li><p>vuex 中在哪儿提交数据更新操作？action 又是干嘛的？</p>
<p>State：提供唯一的公共数据源，所有共享的数据统一放到store的state进行储存，相似与data</p>
<p>Mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数</p>
<p>Action：Action和Mutation相似，一般不用Mutation 异步操作，若要进行异步操作，使用Action</p>
<p>Getter：类似于vue中的computed，进行缓存，对于Store中的数据进行加工处理形成新的数据</p>
<p>Modules：当遇见大型项目时，数据量大，store就会显得很臃肿，为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
</li>
<li><p>vue 的生命周期有哪些</p>
</li>
</ol>
<p>​        beforeCreate：组件实例刚被创建，组件属性计算之前。</p>
<p>​        Created：组件实例刚被创建，属性已绑定，但DOM还未生成。</p>
<p>​        beforeMount：模板编译/挂载之前。</p>
<p>​        Mounted：模板编译/挂载之后。</p>
<p>​        beforeUpdate：组件更新之前。</p>
<p>​        Updated：组件更新之后。</p>
<p>​        beforeDestroy：组件销毁前调用。</p>
<p>​        Destroyed：组件销毁后调用。</p>
<p>​        activated：组件激活时调用。</p>
<p>​        deactivated：组件停用时调用。</p>
<p>​        errorCaptured：当捕获一个来自子孙组件的错误时被调用。</p>
<ol start="15">
<li><p>父组件子组件生命周期钩子函数执行顺序（加载渲染过程、子组件更新过程、父组件更新过程、销毁过程）</p>
<ol>
<li><p>首先是数据加载渲染到页面，包括初始化阶段和挂载阶段<br>Vue实例化（new Vue()）-&gt; 父组件beforeCreate -&gt; 父组件 created -&gt; 父组件 beforeMount -&gt; 子组件 beforeCreate -&gt; 子组件 created -&gt; 子组件 beforeMount -&gt; 真实DOM挂载完毕 -&gt; 子组件 mounted -&gt; 父组件 mounted</p>
</li>
<li><p>其次当data里的数据发生了变化，进入更新阶段<br>父组件 beforeUpdate -&gt; 子组件 beforeUpdate -&gt; 子组件 updated -&gt; 父组件 updated -&gt; 获取更新后的真实DOM</p>
</li>
<li><p>最后当$destroy()被调用进入销毁阶段<br>父组件 beforeDestroy -&gt; 子组件 beforeDestroy -&gt; 实例销毁后 -&gt; 子组件 destroyed -&gt; 父组件 destroyed</p>
</li>
</ol>
</li>
<li><p>vue 懒加载原理</p>
</li>
</ol>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ol>
<li>Xss、csrf</li>
</ol>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><ol>
<li><p>cookie</p>
</li>
<li><p>Cookie、sessionStorage、localStorage</p>
</li>
<li><p>同源策略、跨域</p>
</li>
<li><p>Cors</p>
</li>
<li><p>url 到页面渲染经历了什么</p>
</li>
<li><p>hash 路由和 history 路由</p>
</li>
<li><p>重绘、重排(回流)</p>
<p>重排：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</p>
<p>重绘：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<p>重绘不一定需要重排，重排必然会导致重绘。</p>
</li>
<li><p>localStorage 怎么实现过期时间</p>
</li>
<li><p>html 中 img alt 和 title 属性</p>
</li>
<li><p>V8 内存回收策略</p>
</li>
</ol>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol>
<li>http 对称加密、非对称加密</li>
<li>http 缓存</li>
<li>referer 细节</li>
<li>https 加密过程、为什么</li>
<li>Get、post</li>
<li>304 状态码、cache-control 属性</li>
<li>三次握手</li>
<li>四次挥手</li>
<li>Dns、dns 解析过程、dns 污染</li>
<li>http 与 https 的区别</li>
<li>HTTP 协议底层是用什么协议？这个没答上来，然后出来了下面的问题（引导我回答出 HTTP 底层协议）</li>
<li>网络五层协议、七层协议？</li>
<li>HTTP 协议在哪一层？下面那一层是什么协议？</li>
<li>网络协议为什么要分层？</li>
<li>说一下 http2 的多路复用的概念和原理</li>
</ol>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ol>
<li>wepback</li>
<li>tree shaking、code splitting</li>
<li>webpack 是干嘛用的</li>
<li>webpack 的工作模式，webpack 打包有什么优点</li>
<li>webpack 打包构建是打包构建什么，是 JS 还是 CSS 还是整个前端的工程</li>
<li>webpack 的 loader 这些又是用来干嘛的呢</li>
<li>你配过 webpack 吗</li>
<li>webpack loader 和 plugin 的区别，分别用过哪些</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol>
<li>排序算法</li>
<li>数组和链表的区别</li>
</ol>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol>
<li>token 怎么保持登录状态</li>
<li>登陆状态如何保存</li>
<li>sessionStorage 有什么优势，token 应该放在哪</li>
<li>localStorage 里可以存图片吗，怎么存</li>
<li>token 能放在 cookie 里吗</li>
<li>xss 能不能取到 sessionStorage 里的数据</li>
<li>项目怎么优化</li>
<li>图片懒加载、预加载</li>
<li>商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）</li>
<li>base64 优化的原理</li>
<li>为什么大图片不用 base64，base64 的缺点</li>
<li>图片懒加载是怎么实现的</li>
<li>图片压缩怎么做</li>
<li>gzip 压缩有了解吗</li>
<li>CDN 优化的原理，它怎么做到加速的？</li>
<li>CDN 加速服务器有什么缺点（一个新疆的人访问深圳的服务器，要经过一层一层地找，找到深圳的节点，比直接来深圳的节点拿慢多了，有什么好的方案解决这个问题）</li>
</ol>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol>
<li>react 中 function 和 class 定义组件有什么不同吗？</li>
<li>为什么要使用 redux 呢？dva 的数据流是什么？其同步和异步情况一样吗？</li>
<li>react hooks 用过吗？hooks 是解决什么问题的？useEffect 有什么作用？</li>
<li>react 中，有哪些可以对性能进行优化的点？</li>
<li>mobx 和 redux 的区别</li>
<li>react 生命周期</li>
<li>react 事件机制</li>
<li>React Diff 策略</li>
<li>Redux 中间件？connect 原理</li>
<li>function component 里面怎么进行状态共享？</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>cdn 是什么</li>
<li>packjson 文件里有一些 key，value。其中一个 key 叫 dependencies 和 devDependencies，能说说作用吗</li>
<li>进程和线程区别</li>
<li>模块化概念，有哪些模块化的方式，区别是什么</li>
<li>观察者模式 适配器模式</li>
<li>了解过函数式编程嘛</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/12/14/%E6%9D%82%E8%AE%B0/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">杂记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Js"><span class="toc-number">1.</span> <span class="toc-text">Js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Css"><span class="toc-number">2.</span> <span class="toc-text">Css</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-number">3.</span> <span class="toc-text">Vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">4.</span> <span class="toc-text">安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">浏览器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">6.</span> <span class="toc-text">网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8C%85"><span class="toc-number">7.</span> <span class="toc-text">打包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number">9.</span> <span class="toc-text">项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React"><span class="toc-number">10.</span> <span class="toc-text">React</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">11.</span> <span class="toc-text">其他</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/" title="前端面试"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面试"/></a><div class="content"><a class="title" href="/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/" title="前端面试">前端面试</a><time datetime="2022-12-16T06:33:27.000Z" title="发表于 2022-12-16 14:33:27">2022-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/14/%E6%9D%82%E8%AE%B0/" title="杂记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="杂记"/></a><div class="content"><a class="title" href="/2022/12/14/%E6%9D%82%E8%AE%B0/" title="杂记">杂记</a><time datetime="2022-12-14T08:59:43.000Z" title="发表于 2022-12-14 16:59:43">2022-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/14/axios%E5%B0%81%E8%A3%85/" title="axios封装"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="axios封装"/></a><div class="content"><a class="title" href="/2022/12/14/axios%E5%B0%81%E8%A3%85/" title="axios封装">axios封装</a><time datetime="2022-12-14T02:30:52.000Z" title="发表于 2022-12-14 10:30:52">2022-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/14/vue/" title="vue"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue"/></a><div class="content"><a class="title" href="/2022/12/14/vue/" title="vue">vue</a><time datetime="2022-12-14T02:24:30.000Z" title="发表于 2022-12-14 10:24:30">2022-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/13/vscode/" title="vscode"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vscode"/></a><div class="content"><a class="title" href="/2022/12/13/vscode/" title="vscode">vscode</a><time datetime="2022-12-13T13:29:56.000Z" title="发表于 2022-12-13 21:29:56">2022-12-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>